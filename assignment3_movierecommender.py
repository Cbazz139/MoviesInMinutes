# -*- coding: utf-8 -*-
"""Assignment3-MovieRecommender

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/164abDp-Tw7m_CRZGZ2qhdcTueApP9E4y
"""

!pip install streamlit

import streamlit as st
import requests
import os

# Constants for TMDB API
TMDB_API_BASE_URL = "https://api.themoviedb.org/3"
# For demonstration, we're hardcoding your API token.
# In practice, consider using environment variables.
BEARER_TOKEN = "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIyMTQ3ZDUzNmE4ODZlNzhmZWVhODEwM2MwMTQ2MDFiMiIsIm5iZiI6MTc0MjU4NjY0Mi4yNjEsInN1YiI6IjY3ZGRjMzEyMDUxY2JhOTA2NmY1NjVlOSIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.s65IRbAthvobyw0BlQBz0qbisHXz5Zu9_xDqNAeSp94"

headers = {
    "Authorization": f"Bearer {BEARER_TOKEN}",
    "Content-Type": "application/json;charset=utf-8"
}

def search_movie(query):
    """
    Search for movies by title using TMDB's search endpoint.
    """
    search_url = f"{TMDB_API_BASE_URL}/search/movie"
    params = {"query": query}
    response = requests.get(search_url, headers=headers, params=params)

    if response.status_code == 200:
        data = response.json()
        return data.get("results", [])
    else:
        st.error("Error fetching movie data.")
        return []

def get_recommendations(movie_id):
    """
    Retrieve movie recommendations based on a movie ID.
    """
    rec_url = f"{TMDB_API_BASE_URL}/movie/{movie_id}/recommendations"
    response = requests.get(rec_url, headers=headers)

    if response.status_code == 200:
        data = response.json()
        return data.get("results", [])
    else:
        st.error("Error fetching recommendations.")
        return []

def main():
    st.title("AI-Powered Movie Recommender")
    st.markdown("Enter a movie name to see similar movie recommendations.")

    movie_query = st.text_input("Movie Title:")

    if st.button("Get Recommendations"):
        if movie_query:
            movies = search_movie(movie_query)
            if movies:
                # Use the first search result as the base movie
                movie = movies[0]
                movie_id = movie["id"]
                st.subheader(f"Recommendations based on: {movie.get('title', 'Unknown')}")

                recommendations = get_recommendations(movie_id)
                if recommendations:
                    for rec in recommendations:
                        st.markdown(f"### {rec.get('title', 'No Title')}")
                        poster_path = rec.get("poster_path")
                        if poster_path:
                            poster_url = f"https://image.tmdb.org/t/p/w200{poster_path}"
                            st.image(poster_url)
                        st.write(rec.get("overview", "No description available."))
                        st.markdown("---")
                else:
                    st.write("No recommendations found.")
            else:
                st.write("No movie found with that name.")
        else:
            st.write("Please enter a movie name.")

if __name__ == "__main__":
    main()

!pip install streamlit textblob scikit-learn

import streamlit as st
import requests
from textblob import TextBlob
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Constants for TMDB API
TMDB_API_BASE_URL = "https://api.themoviedb.org/3"
# Use your provided API Read Access Token
BEARER_TOKEN = "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIyMTQ3ZDUzNmE4ODZlNzhmZWVhODEwM2MwMTQ2MDFiMiIsIm5iZiI6MTc0MjU4NjY0Mi4yNjEsInN1YiI6IjY3ZGRjMzEyMDUxY2JhOTA2NmY1NjVlOSIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.s65IRbAthvobyw0BlQBz0qbisHXz5Zu9_xDqNAeSp94"

headers = {
    "Authorization": f"Bearer {BEARER_TOKEN}",
    "Content-Type": "application/json;charset=utf-8"
}

def search_movie(query):
    """
    Search for movies by title using TMDB's search endpoint.
    """
    search_url = f"{TMDB_API_BASE_URL}/search/movie"
    params = {"query": query}
    response = requests.get(search_url, headers=headers, params=params)
    if response.status_code == 200:
        data = response.json()
        return data.get("results", [])
    else:
        st.error("Error fetching movie data.")
        return []

def get_movie_details(movie_id):
    """
    Get detailed information about a movie including genres, ratings, revenue,
    cast, director, and an overview using the 'append_to_response' parameter.
    """
    details_url = f"{TMDB_API_BASE_URL}/movie/{movie_id}"
    params = {"append_to_response": "credits"}
    response = requests.get(details_url, headers=headers, params=params)
    if response.status_code == 200:
        data = response.json()
        # Extract genres as a list of names
        genres = [genre["name"] for genre in data.get("genres", [])]
        # Get revenue, rating, overview
        revenue = data.get("revenue", 0)
        rating = data.get("vote_average", 0)
        overview = data.get("overview", "")
        # Extract cast (top 5) and director
        credits = data.get("credits", {})
        cast_list = credits.get("cast", [])
        cast = [member.get("name") for member in cast_list[:5]] if cast_list else []
        crew_list = credits.get("crew", [])
        director = None
        for member in crew_list:
            if member.get("job") == "Director":
                director = member.get("name")
                break
        return {
            "id": movie_id,
            "title": data.get("title", "Unknown"),
            "overview": overview,
            "genres": genres,
            "revenue": revenue,
            "rating": rating,
            "cast": cast,
            "director": director,
            "poster_path": data.get("poster_path")
        }
    else:
        st.error("Error fetching movie details.")
        return {}

def get_popular_movies(limit=20):
    """
    Fetch a list of popular movies and retrieve detailed information for each.
    """
    popular_url = f"{TMDB_API_BASE_URL}/movie/popular"
    params = {"page": 1}
    response = requests.get(popular_url, headers=headers, params=params)
    movies = []
    if response.status_code == 200:
        data = response.json()
        results = data.get("results", [])[:limit]
        for movie in results:
            movie_id = movie.get("id")
            details = get_movie_details(movie_id)
            if details:
                movies.append(details)
        return movies
    else:
        st.error("Error fetching popular movies.")
        return []

def analyze_sentiment(text):
    """
    Perform sentiment analysis on the provided text using TextBlob.
    Returns polarity and subjectivity.
    """
    blob = TextBlob(text)
    return blob.sentiment.polarity, blob.sentiment.subjectivity

def compute_genre_similarity(genres1, genres2):
    """
    Compute the genre similarity between two movies as the Jaccard similarity.
    """
    set1 = set(genres1)
    set2 = set(genres2)
    if not set1 and not set2:
        return 0
    intersection = set1.intersection(set2)
    union = set1.union(set2)
    return len(intersection) / len(union)

def compute_recommendations(input_movie, candidate_movies, weight_text=0.7, weight_genre=0.3):
    """
    Compute similarity scores between the input movie and candidate movies by
    combining TF-IDF cosine similarity (on overviews) and genre similarity.
    Returns a list of recommended movies sorted by the combined score.
    """
    # Prepare the corpus: input movie overview + candidate movies' overviews
    corpus = [input_movie["overview"]] + [movie["overview"] for movie in candidate_movies]
    vectorizer = TfidfVectorizer(stop_words='english')
    tfidf_matrix = vectorizer.fit_transform(corpus)
    cosine_sim = cosine_similarity(tfidf_matrix[0:1], tfidf_matrix[1:]).flatten()

    recommendations = []
    for idx, candidate in enumerate(candidate_movies):
        genre_sim = compute_genre_similarity(input_movie["genres"], candidate["genres"])
        # Weighted score: combine text similarity and genre similarity
        score = (weight_text * cosine_sim[idx]) + (weight_genre * genre_sim)
        recommendations.append((candidate, score))

    recommendations.sort(key=lambda x: x[1], reverse=True)
    return recommendations

def main():
    st.title("AI-Powered Movie Recommender")
    st.markdown("Enter a movie name to get personalized recommendations based on movie content, genres, and sentiment analysis.")

    movie_query = st.text_input("Movie Title:")

    if st.button("Get Recommendations"):
        if movie_query:
            # Search for the movie and select the first result
            search_results = search_movie(movie_query)
            if search_results:
                selected_movie = search_results[0]
                movie_id = selected_movie["id"]
                input_movie = get_movie_details(movie_id)
                if not input_movie:
                    st.error("Could not retrieve details for the selected movie.")
                    return

                # Display input movie details
                st.subheader(f"Input Movie: {input_movie['title']}")
                st.write(f"**Overview:** {input_movie['overview']}")
                st.write(f"**Genres:** {', '.join(input_movie['genres'])}")
                st.write(f"**Rating:** {input_movie['rating']}")
                st.write(f"**Revenue:** ${input_movie['revenue']:,}")
                st.write(f"**Director:** {input_movie['director']}")
                st.write(f"**Cast:** {', '.join(input_movie['cast'])}")

                # Sentiment analysis for input movie
                polarity, subjectivity = analyze_sentiment(input_movie["overview"])
                st.write(f"**Sentiment (Polarity):** {polarity:.2f}")
                st.write(f"**Sentiment (Subjectivity):** {subjectivity:.2f}")

                # Retrieve a set of candidate movies (using popular movies as a proxy)
                candidate_movies = get_popular_movies(limit=20)
                recommendations = compute_recommendations(input_movie, candidate_movies)

                st.subheader("Recommended Movies:")
                if recommendations:
                    for rec, score in recommendations:
                        st.markdown(f"### {rec.get('title', 'No Title')} (Score: {score:.2f})")
                        st.write(f"**Overview:** {rec.get('overview', 'No overview available.')}")
                        st.write(f"**Genres:** {', '.join(rec.get('genres', []))}")
                        st.write(f"**Rating:** {rec.get('rating', 0)}")
                        st.write(f"**Revenue:** ${rec.get('revenue', 0):,}")
                        st.write(f"**Director:** {rec.get('director', 'N/A')}")
                        st.write(f"**Cast:** {', '.join(rec.get('cast', []))}")
                        # Sentiment analysis for candidate movie
                        cand_polarity, cand_subjectivity = analyze_sentiment(rec.get('overview', ''))
                        st.write(f"**Sentiment (Polarity):** {cand_polarity:.2f}")
                        st.write(f"**Sentiment (Subjectivity):** {cand_subjectivity:.2f}")
                        # Display poster if available
                        poster_path = rec.get("poster_path")
                        if poster_path:
                            poster_url = f"https://image.tmdb.org/t/p/w200{poster_path}"
                            st.image(poster_url)
                        st.markdown("---")
                else:
                    st.write("No recommendations found.")
            else:
                st.write("No movie found with that name.")
        else:
            st.write("Please enter a movie name.")

if __name__ == "__main__":
    main()